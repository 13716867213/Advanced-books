## Java HotSpot VM

- [1.垃圾收集优化简介](#1.垃圾收集优化简介)
    - [1.1什么是垃圾收集器](#1.1什么是垃圾收集器)
    - [1.2为什么选择垃圾收集器很重要](#1.2为什么选择垃圾收集器很重要)
- [2.Ergonomics](#2.Ergonomics)  
    - [2.1垃圾收集器，堆和运行时编译器的默认选择](#2.1垃圾收集器，堆和运行时编译器的默认选择)
    - [2.2基于行为的调整](#2.2基于行为的调整)  
        - [2.2.1最大暂停时间目标](#2.2.1最大暂停时间目标)  
        - [2.2.2吞吐量目标](#2.2.2吞吐量目标)  
        - [2.2.3Footprint](#2.2.3Footprint)  
    - [2.3.调整策略](#2.3.调整策略)  
- [3.垃圾收集器的实现](#3.-垃圾收集器的实现)  
    - [3.1通用垃圾收集](#3.1通用垃圾收集)  
    - [3.2 Generations](#3.2-Generations)  
    - [3.3 性能考量](#3.3-性能考量)  
    - [3.4 吞吐量和足迹测量](#3.4-吞吐量和足迹测量)  
- [4.影响垃圾收集性能的因素](#4.影响垃圾收集性能的因素)      
    - [4.1总堆](#4.1总堆)      
        - [4.1.1影响Generations大小的堆选项](#4.1.1影响Generations大小的堆选项)      
        - [4.1.2堆大小的默认选项值](#4.1.2堆大小的默认选项值)      
        - [4.1.3通过最小化Java堆大小来节省动态占用空间](#4.1.3通过最小化Java堆大小来节省动态占用空间)      
    - [4.2年轻一代](#4.2年轻一代)      
        - [4.2.1年轻代大小选项](#4.2.1年轻代大小选项)      
        - [4.2.2幸存者空间大小](#4.2.2幸存者空间大小)  
- [5.可用收集器](#5.可用收集器)            
        - [5.1串行收集器](#5.1串行收集器)  
        - [5.2并联收集器](#5.2并联收集器)  
        - [5.3垃圾优先G1垃圾收集器](#5.3垃圾优先G1垃圾收集器)  
        - [5.4 Z垃圾收集器](#5.4-Z垃圾收集器)  
        - [5.5选择收集器](#5.5选择收集器)  

### 1.垃圾收集优化简介
从桌面上的小applet到大型服务器上的Web服务，各种各样的应用程序都使用Java平台标准版（Java SE）。
为了支持这种多样化的部署范围，Java HotSpot VM提供了多个垃圾收集器，每个垃圾收集器旨在满足不同的需求。
Java SE根据运行应用程序的计算机的类别选择最合适的垃圾收集器。但是，此选择可能并非对每个应用程序都是最佳的。
具有严格性能目标或其他要求的用户，开发人员和管理员可能需要明确选择垃圾回收器并调整某些参数以实现所需的性能水平。
本文档提供了有助于完成这些任务的信息。

首先，在串行停止世界收集器的上下文中描述了垃圾收集器的一般功能和基本调整选项。
然后介绍了其他收集器的特定功能以及选择收集器时要考虑的因素。
#### 1.1什么是垃圾收集器

垃圾收集器（GC）自动管理应用程序的动态内存分配请求。

垃圾收集器通过以下操作执行自动动态内存管理：

- 从操作系统分配内存并将其还给操作系统。
- 根据请求将内存分发给应用程序。
- 确定应用程序仍在使用该内存的哪些部分。
- 回收未使用的内存，以供应用程序重新使用。

Java HotSpot垃圾收集器采用了各种技术来提高这些操作的效率：

- 将分代清理与老化结合使用，将精力集中在堆中最有可能包含大量可回收内存区域的区域上。
- 使用多个线程来积极地使操作并行化，或者在后台与应用程序并发执行一些长时间运行的操作。
- 尝试通过压缩活动对象来恢复较大的连续可用内存。

#### 1.2为什么选择垃圾收集器很重要

垃圾收集器的目的是使应用程序开发人员摆脱手动动态内存管理。开发人员摆脱了将分配与释放分配进行匹配的需求，
并密切注意分配的动态内存的生命周期。这完全消除了与内存管理有关的某些错误类别，
但付出了一些额外的运行时开销。Java HotSpot VM提供了一系列垃圾收集算法供您选择。

什么时候选择垃圾收集器很重要？对于某些应用程序，答案永远是不可能的。也就是说，在存在垃圾收集的情况下，
应用程序可以在频率和持续时间适度的暂停下表现良好。但是，对于大类应用程序却不是这种情况，
尤其是那些具有大量数据（数千兆字节），许多线程和高事务处理率的应用程序。

阿姆达尔定律（给定问题中的并行加速受问题的顺序部分限制）意味着大多数工作负载无法完美并行化；
某些部分始终是顺序的，不能从并行性中受益。在Java平台中，当前有4种受支持的垃圾收集替代方案，
除其中一种（串行GC）之外，其余所有方案均并行进行以提高性能。尽可能减少垃圾收集的开销非常重要。在下面的示例中可以看到。

图1-1中的图对理想系统进行了建模，该系统除了垃圾回收外，还具有完美的可伸缩性。
红线表示应用程序仅在单处理器系统上花费1％的时间进行垃圾回收。在具有32个处理器的系统上，这意味着吞吐量损失超过20％。
洋红线显示，对于一个应用程序来说，垃圾回收的时间为10％（在单处理器应用程序中，垃圾回收的时间不算多），
当扩展到32个处理器时，将损失超过75％的吞吐量。

图1-1比较垃圾回收中花费的时间百分比

![图1-1比较垃圾回收中花费的时间百分比](../../../doc/java/jvm/jvm01.png)

该图表明，在小型系统上进行开发时，可忽略的吞吐量问题可能会在扩展到大型系统时成为主要瓶颈。
但是，在减少这种瓶颈方面进行小的改进可以提高性能。
对于足够大的系统，有必要选择正确的垃圾收集器并在必要时进行调整。

串行收集器通常适合大多数小型应用程序，特别是那些在现代处理器上需要高达约100 MB的堆的应用程序。
其他收集器具有额外的开销或复杂性，这是专门行为的代价。如果应用程序不需要备用收集器的特殊行为，请使用串行收集器。
不能期望串行收集器是最佳选择的一种情况是大型，高线程应用程序运行在具有大量内存和两个或多个处理器的计算机上。
在此类服务器级计算机上运行应用程序时，默认情况下会选择“垃圾优先”（G1）收集器；

### 2.Ergonomics

人体工程学是Java虚拟机（JVM）和垃圾收集启发法（例如基于行为的启发法）提高应用程序性能的过程。

JVM为垃圾收集器，堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择可满足不同类型应用程序的需求，
同时需要较少的命令行调整。此外，基于行为的调整可动态优化堆的大小，以满足应用程序的指定行为。

本节描述了这些默认选择和基于行为的调整。在使用后续各节中介绍的更详细的控件之前，请使用这些默认值。

#### 2.1垃圾收集器，堆和运行时编译器的默认选择

这些是重要的垃圾收集器，堆大小和运行时编译器的默认选择： 

- 垃圾优先（G1）收集器
- GC线程的最大数量受堆大小和可用CPU资源的限制 
- 初始堆大小为物理内存的1/64 
- 最大堆大小为物理内存的1/4 
- 使用C1和C2的分层编译器 

#### 2.2基于行为的调整

可以将Java HotSpot VM垃圾收集器配置为优先满足以下两个目标之一：
最大暂停时间和应用程序吞吐量。如果达到了首选目标，则收集者将尝试使另一个最大化。
自然地，这些目标并不总是可以满足的：应用程序需要最小的堆来容纳至少所有实时数据，
而其他配置可能会阻止达到某些或所有期望的目标。

##### 2.2.1最大暂停时间目标

在暂停时间是在垃圾收集器停止应用程序并恢复空间不再使用的持续时间。其意图*最大停顿时间*目标是限制最长的这些暂停的。

垃圾回收器会保持平均的暂停时间和该平均值的方差。平均值是从执行开始算起的，但会对其进行加权，以使最近的暂停次数增加。
如果平均时间加上暂停时间的方差大于最大暂停时间目标，则垃圾收集器认为未达到目标。

最大暂停时间目标是通过命令行选项`-XX:MaxGCPauseMillis=<nnn>`*指定的*。这被解释为向垃圾收集器的提示，要求暂停时间为**毫秒*或更短*。
垃圾收集器会调整Java堆大小以及与垃圾收集相关的其他参数，以使垃圾收集的暂停时间短于**毫秒。最大暂停时间目标的默认值因收集器而异。
这些调整可能导致垃圾回收更加频繁地发生，从而降低了应用程序的整体吞吐量。但是，在某些情况下，无法达到所需的暂停时间目标。

##### 2.2.2吞吐量目标

吞吐量目标是根据收集垃圾所花费的时间来衡量的，而在垃圾收集之外所花费的时间就是*应用时间*。

该目标由命令行选项`-XX:GCTimeRatio=<nnn>`指定。垃圾回收时间与应用程序时间之比为1 /（1+ *nnn*）。
例如，`-XX:GCTimeRatio=19`将垃圾收集目标设置为目标1/20或总时间的5％。

垃圾收集所花费的时间是所有垃圾收集引起的暂停的总时间。如果没有达到吞吐量目标，
那么垃圾收集器可能采取的一种措施是增加堆的大小，以便在两次收集暂停之间花费在应用程序中的时间可以更长。

#### 2.2.3Footprint

如果已满足吞吐量和最大暂停时间目标，则垃圾收集器会减小堆的大小，直到无法满足其中一个目标（始终是吞吐量目标）。
可以分别使用` -Xms=`**和`-Xmx=`**分别设置垃圾收集器可以使用的最小和最大堆大小，以分别指定最小和最大堆大小。

#### 2.3.调整策略

堆增长或缩小到支持所选吞吐量目标的大小。了解有关堆调整策略的信息，例如选择最大堆大小和选择最大暂停时间目标。

除非您知道需要的堆大于默认的最大堆大小，否则不要为堆选择最大值。选择适合您的应用程序的吞吐量目标。

应用程序行为的更改可能导致堆增大或缩小。例如，如果应用程序开始以更高的速率分配，那么堆会增长以保持相同的吞吐量。

如果堆增长到最大大小并且未达到吞吐量目标，则最大堆大小对于吞吐量目标而言太小。将最大堆大小设置为接近平台上总物理内存的值，
但不会导致应用程序交换。再次执行该应用程序。如果仍然没有达到吞吐量目标，那么对于平台上的可用内存来说，应用程序时间目标太高了。

如果可以满足吞吐量目标，但暂停时间太长，则选择最大暂停时间目标。选择最大暂停时间目标可能意味着您的吞吐量目标将无法实现，因此请选择对应用程序可接受的折衷值。

当垃圾收集器试图满足竞争目标时，堆的大小通常会发生波动。即使应用程序已达到稳定状态，也是如此。达到吞吐量目标（可能需要更大的堆）的压力与目标竞争，
以获得最大的暂停时间和最小的占用空间（这两者都可能需要一个小堆）。

### 3. 垃圾收集器的实现
Java SE平台的优势之一在于，它使开发人员免受内存分配和垃圾回收的复杂性的困扰。

但是，当垃圾收集是主要瓶颈时，了解实现的某些方面很有用。垃圾收集器对应用程序使用对象的方式进行了假设，
这些反映在可调整的参数中，可以调整这些参数以提高性能，而不会牺牲抽象的力量。

#### 3.1通用垃圾收集

当无法从正在运行的程序中任何其他活动对象的任何引用中访问该对象时，该对象被视为垃圾，并且VM可以重用其内存。

一种理论上最直接的垃圾回收算法，每次运行时都会遍历每个可到达的对象。任何剩余的对象都被视为垃圾。
这种方法花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序是不允许的。

Java HotSpot VM包含许多不同的垃圾收集算法，除了ZGC使用称为通用收集的技术外，所有算法均如此。
垃圾收集每次都会检查堆中的每个活动对象，而分代收集则利用大多数应用程序的经验观察到的属性，
以最大程度地减少回收未使用（垃圾）对象所需的工作。这些观察到的特性中最重要的是弱代假设，
该假设指出大多数物体只能存活很短的时间。

图3-1中的蓝色区域是对象生命周期的典型分布。x轴显示以分配的字节为单位的对象寿命。
、y轴上的字节数是具有相应生存期的对象中的总字节数。左侧的尖峰表示分配后可以回收的对象（换句话说，已经“死亡”）。
例如，iterator对象通常仅在单个循环的时间内才存在。

图3-1对象生命周期的典型分布
![图3-1对象生命周期的典型分布](../../../doc/java/jvm/jvm02.png)

有些对象的寿命更长，因此分布向右扩展。例如，通常在初始化时分配一些对象，这些对象会一直存在直到VM退出。
在这两个极端之间的是在某些中间计算过程中存在的对象，此处被视为初始峰值右侧的块。
一些应用程序的外观分布非常不同，但是令人惊讶的是，大量应用程序具有这种总体形状。
通过关注大多数对象“早逝”这一事实，可以进行有效的收集。

#### 3.2 Generations

为了针对这种情况进行优化，内存要分代管理（存储着不同年龄对象的内存池）。
当`Generations`填满时，垃圾回收会在每个`Generations`中发生。

绝大多数对象分配在专用于年轻对象（年轻一代）的池中，并且大多数对象在那里死亡。
当年轻一代填满时，将导致次要集合，其中仅收集年轻一代。没有回收其他`Generations`的垃圾。
首先，这种收集的费用与所收集的有生命物体的数量成正比；可以很快收集到充满死亡物体的年轻一代。
通常，在每个次要收藏期间，来自年轻一代的幸存对象中有一部分会转移到老一代。
最终，老一代人填满了，必须被收集起来，导致大量收集，其中收集了整个堆。
主要集合的持续时间通常比次要集合的持续时间长得多，因为涉及的对象数量大得多。
图3-2显示了串行垃圾收集器中各代的默认排列：
![图3-2显示了串行垃圾收集器中各代的默认排列](../../../doc/java/jvm/jvm03.png)

在启动时，Java HotSpot VM会在地址空间中保留整个Java堆，但除非需要，
否则不会为其分配任何物理内存。从逻辑上讲，覆盖Java堆的整个地址空间都分为年轻一代和老一代。
保留给对象存储器的完整地址空间可以分为年轻一代和老一代。

年轻一代由伊甸园和两个幸存者空间组成。大多数对象最初是在eden中分配的。
一个幸存者空间随时都是空的，在伊甸园中用作活动对象的目的地，而在垃圾回收期间，另一个幸存者空间用作目的地；垃圾回收后，
伊甸园和源幸存者空间为空。在下一个垃圾收集中，交换了两个幸存者空间的目的。
最近填充的一个空间是复制到另一个幸存者空间中的活动对象的来源。以这种方式在幸存者空间之间复制对象，
直到将它们复制了一定次数或空间不足为止。这些对象被复制到旧区域中。此过程也称为老化。

#### 3.3 性能考量

垃圾收集的主要衡量指标是吞吐量和延迟。

- *吞吐量*是长时间内未花费在垃圾收集上的总时间的百分比。吞吐量包括分配所花费的时间（但是通常不需要调整分配速度）。
- *延迟*是应用程序的响应能力。垃圾收集暂停会影响应用程序的响应速度。

用户对垃圾回收有不同的要求。例如，有些人认为Web服务器的正确度量标准是吞吐量，因为垃圾回收期间的暂停可能是可以容忍的，
或者可能被网络延迟所掩盖。但是，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。

一些用户对其他注意事项敏感。*足迹*是流程的工作集，以页和缓存行为单位。在物理内存有限或有许多进程的系统上，
占用空间可能决定可伸缩性。*及时性*是当一个物体变得死亡之间的时间当内存可用，分布式系统，包括远程方法调用（RMI）的重要考虑因素。

通常，为特定`Generations`选择大小是这些考虑之间的权衡。例如，一个非常大的年轻一代可以最大化吞吐量，但是这样做会以占用空间，
及时性和暂停时间为代价。可以通过使用少量的年轻一代来最小化年轻一代的停顿，但会降低吞吐量。
一代的大小不会影响另一一代的收集频率和暂停时间。

没有选择`Generations`大小的正确方法。最佳选择取决于应用程序使用内存的方式以及用户需求。
因此，虚拟机对垃圾收集器的选择并非总是最佳选择，并且可能会被命令行选项所取代。

#### 3.4 吞吐量和足迹测量

吞吐量和占用空间最好使用特定于应用程序的指标来衡量。

例如，可以使用客户端负载生成器来测试Web服务器的吞吐量。但是，通过检查虚拟机本身的诊断输出，很容易估计由于垃圾收集而引起的暂停。命令行选项`-verbose:gc `在每个集合上输出有关堆和垃圾回收的信息。这是一个例子：

```
[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M->57M(307M) (15,646s, 15,651s) 5,048ms
[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M->57M(307M) (16,146s, 16,162s) 16,565ms
[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M->31M(104M) (16,202s, 16,367s) 164,581ms
```

输出显示两个年轻集合，然后是由应用程序调用发起的完整集合`System.gc()`。这些行以时间戳记开始，指示从应用程序启动开始的时间。接下来是有关该行的日志级别（info）和标签（gc）的信息。其后是GC标识号。在这种情况下，存在三个GC，其编号分别为36、37和38。然后记录GC的类型和说明GC的原因。此后，将记录有关内存消耗的一些信息。该日志使用“ GC前使用”->“ GC后使用”（“堆大小”）的格式。

在示例的第一行中，这是239M-> 57M（307M），这意味着在GC之前使用了239 MB，GC清除了大部分内存，但仍有57 MB可用。堆大小为307 MB。请注意，在此示例中，完整的GC将堆从307 MB缩小到104 MB。在内存使用信息之后，将记录GC的开始和结束时间以及持续时间（结束-开始）。

该`-verbose:gc`命令是的别名`-Xlog:gc`。`-Xlog`是用于登录HotSpot JVM的常规日志记录配置选项。这是一个基于标签的系统，其中`gc`是标签之一。要获取有关GC正在执行的操作的更多信息，可以配置日志记录以打印具有` gc`标签和任何其他标签的任何消息。的命令行选项是` -Xlog:gc`。

这是一个用G1记录的G1年轻系列的示例`-Xlog:gc`：

```verilog
[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause) 
[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation 
[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms
[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms 
[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms 
[10.191s][info][gc,phases ] GC(36) Other: 0.2ms 
[10.191s][info][gc,heap ] GC(36) Eden regions: 286->0(276) 
[10.191s][info][gc,heap ] GC(36) Survivor regions: 15->26(38)
[10.191s][info][gc,heap ] GC(36) Old regions: 88->88 
[10.191s][info][gc,heap ] GC(36) Humongous regions: 3->1 
[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K->8152K(1056768K)
[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M->114M(508M) 13.075ms 
[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s
```

注意：

产生的输出格式`-Xlog:gc`在将来的发行版中可能会更改。

### 4.影响垃圾收集性能的因素
影响垃圾收集性能的两个最重要因素是总可用内存和专用于年轻一代的堆的比例。

#### 4.1总堆

影响垃圾收集性能的最重要因素是总可用内存。由于收集是在`Generations`填满时发生的，因此吞吐量与可用内存量成反比。

>注意：
>以下有关堆的增长和收缩，堆布局和默认值的讨论以串行收集器为例。尽管其他收集器使用类似的机制，
>但此处介绍的详细信息可能不适用于其他收集器。有关其他收集器的类似信息，请参阅相应主题。

#### 4.1.1影响Generations大小的堆选项

许多选项会影响`Generations`大小。图4-1说明了堆中已提交空间和虚拟空间之间的区别。在虚拟机初始化时，
将保留堆的整个空间。可以使用该`-Xmx`选项指定保留空间的大小。如果`-Xms`参数的值小于参数的值` -Xmx`，
则并非所有保留的空间都会立即提交给虚拟机。在此图中，未使用的空间标记为“虚拟”。
堆的不同部分，即老一辈和年轻一代，可以根据需要增长到虚拟空间的极限。

一些参数是堆的一部分与另一部分的比率。例如，该参数`–XX:NewRatio`表示老一代对年轻一代的相对大小。
图4-1堆选项
![图4-1堆选项](../../../doc/java/jvm/jvm04.png)

#### 4.1.2堆大小的默认选项值

默认情况下，虚拟机在每个集合上增加或缩小堆，以尝试将每个集合中活动对象的可用空间比例保持在特定范围内。

该目标范围由选项`-XX:MinHeapFreeRatio=`**和`-XX:MaxHeapFreeRatio=`**设置为百分比，
总大小由限制在下方，`–Xms```而由限制在上方`–Xmx```。

使用这些选项，如果某代中的可用空间百分比下降到40％以下，则该代将扩展以维持40％的可用空间，
直到该代最大允许的大小。同样，如果可用空间超过70％，则生成会收缩，因此只有70％的空间可用，这取决于生成的最小大小。

Java SE中为Parallel收集器使用的计算现在已用于所有垃圾收集器。计算的一部分是64位平台的最大堆大小的上限。

以下是有关服务器应用程序堆大小的一般准则：

- 除非您在暂停方面遇到问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常太小。
- 通过从虚拟机中删除最重要的大小决策，将`-Xms`和设置`-Xmx`为相同的值可以提高可预测性。但是，如果选择不当，虚拟机将无法补偿。
- 通常，随着处理器数量的增加，内存也会增加，因为分配可以并行进行。

#### 4.1.3通过最小化Java堆大小来节省动态占用空间

如果您需要最小化应用程序的动态内存占用量（在执行过程中消耗的最大RAM），则可以通过最小化Java堆大小来做到这一点。
Java SE Embedded应用程序可能需要这样做。

通过使用命令行选项和降低选项的值` -XX:MaxHeapFreeRatio`（默认值为70％）和`-XX:MinHeapFreeRatio`（默认值为40％）
来最小化Java堆大小。降低到10％，并且已经显示出可以成功减小堆大小而不会导致过多的性能下降；
但是，结果可能会因您的应用程序而有很大差异。对这些参数尝试不同的值，直到它们尽可能的低，但仍保持可接受的性能。
 `-XX:MaxHeapFreeRatio``-XX:MinHeapFreeRatio``-XX:MaxHeapFreeRatio``-XX:MinHeapFreeRatio`

另外，您可以指定`-XX:-ShrinkHeapInSteps`，这会立即将Java堆减小到目标大小（由参数指定`-XX:MaxHeapFreeRatio`）。
使用此设置可能会导致性能下降。默认情况下，Java运行时以递增方式将Java堆减小到目标大小。此过程需要多个垃圾回收周期。

#### 4.2年轻一代

在总可用内存之后，影响垃圾收集性能的第二大影响因素是专用于年轻一代的堆的比例。

年轻一代越大，收藏的次数就越少。但是，对于有限的堆大小，较大的年轻代意味着较小的旧代，这将增加主要集合的频率。
最佳选择取决于应用程序分配的对象的生命周期分布。

#### 4.2.1年轻代大小选项

默认情况下，年轻代大小由option控制`-XX:NewRatio`。

例如，设置`-XX:NewRatio=3`意味着年轻一代与老一代之间的比例为1：3。换句话说，伊甸园和幸存者空间的总大小将是堆总大小的四分之一。

这些选择`-XX:NewSize`和`-XX:MaxNewSize`限制了年轻一代的大小。这些设置为相同的值修正的年轻一代，
就像设置`-Xms`和`-Xmx`相同的值修正总堆大小。这对于以比允许的整数倍更好的粒度调整年轻一代很有用`-XX:NewRatio`。

#### 4.2.2幸存者空间大小
您可以使用该选项-XX:SurvivorRatio来调整幸存者空间的大小，但这通常对性能并不重要。

例如，-XX:SurvivorRatio=6将伊甸园和幸存者空间之间的比例设置为1：6。换句话说，
每个幸存者空间将是伊甸园大小的六分之一，因此是年轻一代的八分之一（而不是七分之一，因为有两个幸存者空间）。

如果幸存者空间太小，那么复制集合将直接溢出到旧一代中。如果幸存者空间太大，那么它们将毫无用处。
在每次垃圾回收时，虚拟机都会选择一个阈值数，该阈值是对象在旧之前可以复制的次数。
选择此阈值可使幸存者半满。您可以使用日志配置`-Xlog:gc`,age来显示此阈值和新一代对象的使用期限。
这对于观察应用程序的生命周期分布也很有用。

**表4-1幸存者空间大小调整的默认选项值**

| 选项                | 默认值     |
| :------------------ | :--------- |
| `-XX:NewRatio`      | 2          |
| `-XX:NewSize`       | 1310兆字节 |
| `-XX:MaxNewSize`    | 不限       |
| `-XX:SurvivorRatio` | 8          |

从总堆的最大大小和`-XX:NewRatio`参数的值计算出年轻代的最大大小。参数的“不受限制”默认值`-XX:MaxNewSize`表示，
`-XX:MaxNewSize`除非`-XX:MaxNewSize`在命令行上指定的值，否则计算值不受限制。

以下是服务器应用程序的一般准则：

- 首先确定您可以负担得起的虚拟机的最大堆大小。然后，针对年轻一代的尺寸绘制性能指标，以找到最佳设置。
  - 请注意，最大堆大小应始终小于计算机上安装的内存量，以避免过多的页面错误和崩溃。
- 如果总堆大小是固定的，则增加年轻代大小需要减少旧代大小。保留足够大的旧一代以容纳应用程序在任何给定时间使用的所有实时数据，
以及一定数量的空闲空间（10％到20％或更多）。
- 遵守先前对旧一代的限制：
  - 给年轻一代留下很多记忆。
  - 随着处理器数量的增加，可以增加年轻代的大小，因为分配可以并行化。
  
### 5.可用收集器  

到目前为止，讨论的是串行收集器。Java HotSpot VM包括三种不同类型的收集器，每种收集器具有不同的性能特征。

#### 5.1串行收集器

串行收集器使用单个线程来执行所有垃圾收集工作，这使之相对高效，因为线程之间没有通信开销。

它最适合单处理器计算机，因为它不能利用多处理器硬件，
尽管它在多处理器上对于数据集较小（最大约100 MB）的应用很有用。
默认情况下，在某些硬件和操作系统配置上选择了串行收集器，或者可以使用选项明确启用串行收集器`-XX:+UseSerialGC`。

#### 5.2并联收集器

并行收集器也称为*吞吐量收集器*，它是类似于串行收集器的分代收集器。
串行收集器和并行收集器之间的主要区别是并行收集器具有多个线程，这些线程用于加速垃圾收集。

并行收集器旨在用于具有在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。您可以使用`-XX:+UseParallelGC`选项启用它。

并行压缩是使并行收集器能够并行执行主要收集的功能。如果没有并行压缩，则使用单个线程执行主要集合，
这会大大限制可伸缩性。如果`-XX:+UseParallelGC`已指定选项，则默认情况下启用并行压缩。
您可以使用` -XX:-UseParallelOldGC `选项禁用它。

#### 5.3垃圾优先G1垃圾收集器

G1是一个并发收集器。通常，并发收集器会与应用程序同时执行一些昂贵的工作。
该收集器旨在从小型计算机扩展到具有大量内存的大型多处理器计算机。它提供了以高概率满足暂停时间目标的能力，同时实现了高吞吐量。

默认情况下，G1在大多数硬件和操作系统配置中处于选中状态，或者可以使用明确启用`-XX:+UseG1GC`。

#### 5.4 Z垃圾收集器

Z垃圾收集器（ZGC）是可伸缩的低延迟垃圾收集器。ZGC同时执行所有昂贵的工作，而不会停止执行应用程序线程。

ZGC适用于需要低延迟（少于10毫秒的暂停）和/或使用非常大的堆（数TB）的应用程序。您可以使用`-XX:+UseZGC`选项启用。

从JDK 11开始，ZGC作为实验功能可用。

#### 5.5选择收集器

除非您的应用程序有非常严格的暂停时间要求，否则请先运行您的应用程序并允许VM选择收集器。

如有必要，请调整堆大小以提高性能。如果性能仍然不能满足您的目标，请使用以下准则作为选择收集器的起点：

- 如果应用程序的数据集较小（最大约为100 MB），则选择带有选项的串行收集器`-XX:+UseSerialGC`。
- 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有选项的串行收集器`-XX:+UseSerialGC`。
- 如果（a）峰值应用程序性能是第一要务，并且（b）没有暂停时间要求或一秒或更长时间的暂停是可接受的，
    则让VM选择收集器或使用选择并行收集器`-XX:+UseParallelGC`。
- 如果响应时间比整体吞吐量更重要，并且必须将垃圾收集暂停时间保持更短，那么请使用选择并发的收集器`-XX:+UseG1GC`。
- 如果响应时间是高优先级，和/或您使用的堆非常大，请使用选择一个完全并发的收集器`-XX:UseZGC`。

这些准则只是选择收集器的起点，因为性能取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度。

如果推荐的收集器没有达到所需的性能，则首先尝试调整堆和生成大小以达到所需的目标。
如果性能仍然不足，请尝试使用其他收集器：使用并发收集器来减少暂停时间，并使用并行收集器来增加多处理器硬件上的总体吞吐量。







## 4.15 函数调用优化

MySQL函数在内部被标记为确定性或不确定性。如果给定参数固定值的函数可以为不同的调用返回不同的结果，则它是不确定的。不确定函数的示例： `RAND()`， `UUID()`。

如果某个函数被标记为不确定的，则将`WHERE`针对每一行（从一个表中选择时）或行组合（从多表联接中选择时）评估子句中对该函数的引用。

MySQL还根据参数的类型（参数是表列还是常量值）确定何时评估函数。每当表列更改值时，都必须评估将表列作为参数的确定性函数。

非确定性函数可能会影响查询性能。例如，某些优化可能不可用，或者可能需要更多锁定。以下讨论使用 `RAND()`但也适用于其他不确定性函数。

假设一个表`t`具有以下定义：

```sql
CREATE TABLE t (id INT NOT NULL PRIMARY KEY, col_a VARCHAR(100));
```

考虑以下两个查询：

```sql
SELECT * FROM t WHERE id = POW(1,2);
SELECT * FROM t WHERE id = FLOOR(1 + RAND() * 49);
```

由于与主键的相等性比较，两个查询似乎都使用了主键查找，但这仅适用于第一个查询：

- 第一个查询始终最多产生一行，因为`POW()`带有常量参数的常量是一个常量值，并且用于索引查找。
- 第二个查询包含一个使用非确定性函数的表达式，该表达式 `RAND()`在查询中不是常数，但实际上对于表的每一行都有一个新值`t`。因此，查询读取表的每一行，评估每一行的谓词，并输出主键与随机值匹配的所有行。根据`id`列值和`RAND()`序列中的值， 它可以是零行，一行或多行 。

非确定性的影响不仅限于 `SELECT`陈述。该 `UPDATE`语句使用非确定性函数来选择要修改的行：

```sql
UPDATE t SET col_a = some_expr WHERE id = FLOOR(1 + RAND() * 49);
```

大概目的是最多更新主键与表达式匹配的一行。但是，它可能会更新零，一或多个行，具体取决于 `id`列值和`RAND()`序列中的值 。

刚刚描述的行为对性能和复制有影响：

- 由于不确定函数不会产生恒定值，因此优化器无法使用其他可能适用的策略，例如索引查找。结果可能是表扫描。
- `InnoDB` 可能升级为范围键锁，而不是为一个匹配的行获取单行锁。
- 无法确定执行的更新对于复制是不安全的。

困难源于`RAND()`对表的每一行都对函数进行一次评估的事实 。为了避免进行多功能评估，请使用以下技术之一：

- 将包含不确定性函数的表达式移到单独的语句，将值保存在变量中。在原始语句中，将表达式替换为对变量的引用，优化器可以将该变量视为常量值：

  ```sql
  SET @keyval = FLOOR(1 + RAND() * 49);
  UPDATE t SET col_a = some_expr WHERE id = @keyval;
  ```

- 将随机值分配给派生表中的变量。此技术使变量在`WHERE`子句中的比较中使用之前被分配一个值 ：

  ```sql
  SET optimizer_switch = 'derived_merge=off';
  UPDATE t, (SELECT @keyval := FLOOR(1 + RAND() * 49)) AS dt
  SET col_a = some_expr WHERE id = @keyval;
  ```

如前所述，`WHERE`子句中的不确定性表达式 可能会阻止优化并导致表扫描。但是，`WHERE`如果其他表达式是确定性的，则可以部分优化该子句。例如：

```sql
SELECT * FROM t WHERE partial_key=5 AND some_column=RAND();
```

如果优化器可以`partial_key`用来减少选择的行的集合， `RAND()`则执行的次数更少，这可以减少不确定性对优化的影响。